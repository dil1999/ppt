%queens
%Entry point
slove(Solution):-
    Solution = [Q1,Q2,Q3,Q4],

    % Each Queens should in different row and column
    permutation([1,2,3,4], Solution),

    %Initial State
    safe(Q1,Q2, 1),
    safe(Q1,Q3, 2),
    safe(Q1,Q4, 3),
    safe(Q2,Q3, 1),
    safe(Q2,Q4, 2),
    safe(Q3,Q4, 1).

% Safe predicate
safe(X, Y, Dist) :-
    Diff is X -Y,
    abs(Diff)=\= Dist.

%Ultimate predication
permutation([], []).
permutation(List, [H|Perm]):-
    select(H, List, Rest),
    permutation(Rest,Perm).

%Utility predication
select(X, [X | Tail], Tail).
select(Elem, [Head | Tail], [Head|Rest]):-
    select(Elem, Tail, Rest).


%rivercrossing
other_bank(e,w).
other_bank(w,e).

move([X,X,G,C], wolf,[Y,Y,G,C]):-other_bank(X,Y).
move([X,W,X,C], goat,[Y,W,Y,C]):-other_bank(X,Y).
move([X,W,G,X], cabbage,[Y,W,G,Y]):-other_bank(X,Y).
move([X,W,G,C], farmer,[Y,W,G,C]):-other_bank(X,Y).

safety_ck(X,X,_).
safety_ck(X,_,X).

safe_status([M, W, G, C]):-
    safety_ck(M,G,W),
    safety_ck(M,G,C).

solution([e,e,e,e],[]).
solution(Config, [Move | OtherMoves] ):-
          move(Config, Move, NextConfig),
          safe_status(NextConfig),
          solution(NextConfig, OtherMoves).



%length(X, 7), solution([W,W,W,W], X).

%waterjug
water_jug(X,Y):-
    X > 4, Y < 3,
    write('4L Jug iS Overflowing....').

water_jug(X,Y):-
    X < 4, Y > 3,
    write('3L Jug is Overflowing....').
water_jug(X,Y):-
    X > 4, Y > 3,
    write('Both water jugs are Over flowing....').

water_jug(X, Y):-
    (
      X=:=0,Y=:=0, nl,
      write('4L:4 & 3L:0 (Action: Fill 4L Jug.)'),
      XX is 4,
      water_jug(XX,Y)
    );
    (
      X=:=0,Y=:=0, nl,
      write('4L:0 & 3L:3 (Action: Fill 3L Jug.)'),
      YY is 3,
      water_jug(X,YY)
    );
    (
        X=:=0, Y=:=3, nl,
        write('4L:0 & 3L:3 (Action: Pour water From 3L tO 4l.)'),
        XX is Y, YY is Y-Y,
        water_jug(XX,YY)

    );
    (
        X=:=3, Y=:=0,nl,
        write('4L:3 & 3L:0 (Action: Fill 3L Jug with water)'),
        YY is 3,
        water_jug(X,YY)
    );
    (
        X=:=3, Y=:=3,nl,
        write('4L:3 & 3L:3 (Action: Pour water from 3L -> 4L, Untill 4L Fill)'),
        XX is X + (4-Y), YY is Y-1,
        water_jug(XX,YY)
    );
    (
       X=:=4, Y=:=2,nl,
       write('4L:4 & 3L:2 (Action: Empty 4L.)'),
       XX is 0,
       water_jug(XX,Y)
    );
    (
      X=:=0, Y=:=2,nl,
      write('4L:0 & 3L:2 (Action: Pour 3L water into 4L)'),
      XX is Y, YY is 0,
      water_jug(XX, YY)
    );

    (
      X=:=2, Y=:=0,nl,
      write('4L:2 & 3L:0 (Action: Goal Reached)')
    ).

% missonary
% Initial state: All missionaries and cannibals are on the left side.
initial_state(state(3, 3, 0, 0, left)).

% Goal state: All missionaries and cannibals are on the right side.
goal_state(state(0, 0, 3, 3, right)).

% Valid state predicate: Checks if a state is valid
valid(state(ML, CL, MR, CR, _)) :-
    ML >= 0, CL >= 0, MR >= 0, CR >= 0,
    (ML = 0; ML >= CL),
    (MR = 0; MR >= CR).

% Moves definition
move(state(ML, CL, MR, CR, left), state(ML2, CL2, MR2, CR2, right)) :-
    % move 2 missionaries
    ML2 is ML - 2, MR2 is MR + 2, CL2 is CL, CR2 is CR;
    % move 2 cannibals
    ML2 is ML, MR2 is MR, CL2 is CL - 2, CR2 is CR + 2;
    % move 1 missionary and 1 cannibal
    ML2 is ML - 1, MR2 is MR + 1, CL2 is CL - 1, CR2 is CR + 1;
    % move 1 missionary
    ML2 is ML - 1, MR2 is MR + 1, CL2 is CL, CR2 is CR;
    % move 1 cannibal
    ML2 is ML, MR2 is MR, CL2 is CL - 1, CR2 is CR + 1.

move(state(ML, CL, MR, CR, right), state(ML2, CL2, MR2, CR2, left)) :-
    % move 2 missionaries
    ML2 is ML + 2, MR2 is MR - 2, CL2 is CL, CR2 is CR;
    % move 2 cannibals
    ML2 is ML, MR2 is MR, CL2 is CL + 2, CR2 is CR - 2;
    % move 1 missionary and 1 cannibal
    ML2 is ML + 1, MR2 is MR - 1, CL2 is CL + 1, CR2 is CR - 1;
    % move 1 missionary
    ML2 is ML + 1, MR2 is MR - 1, CL2 is CL, CR2 is CR;
    % move 1 cannibal
    ML2 is ML, MR2 is MR, CL2 is CL + 1, CR2 is CR - 1.

% State transition: Defines a valid move from one state to another
transition(State, NextState) :-
    move(State, NextState),
    valid(NextState).

% Solve the problem
solve :-
    initial_state(State),
    goal_state(Goal),
    path(State, Goal, [State], Path),
    print_path(Path).

% Path-finding: Recursively find a path from the initial state to the goal state
path(Goal, Goal, Path, Path).
path(State, Goal, Visited, Path) :-
    transition(State, NextState),
    \+ member(NextState, Visited),  % Ensure that the state has not been visited
    path(NextState, Goal, [NextState|Visited], Path).

% Print the solution
print_path([]).
print_path([State|Rest]) :-
    write(State), nl,
    print_path(Rest).

% Query to start the solution
start :- solve.
